// Copyright (c) 2023 Alan Parra
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
// the Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

package main

import (
	"flag"
	"fmt"
	"io"
	"os"
	"text/template"

	"github.com/grpc-ecosystem/grpc-gateway/v2/runtime"
	"golang.org/x/exp/slices"
	"google.golang.org/grpc/codes"
)

var outFile = flag.String("o", "-", "Output file. Use '-' for os.Stdout.")

type codeInfo struct {
	Num      int
	HTTP     int
	HTTPSkip bool
	Name     string
	Desc     string
	Semerr   string
}

var generateT = template.Must(template.
	New("generate").
	Parse(`// Copyright (c) 2023 Alan Parra
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
// the Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

// Code generated by ./internal/cmd/generate. DO NOT EDIT.

package semerr

var errFromCode = map[Code]func(error) error{
{{- range $i, $info := .infos}}
	{{$info.Num | printf "%d:" | printf "%-3s"}} func(err error) error { return {{$info.Semerr}}{err} },
{{- end}}
}

var errFromStatus = map[int]func(error) error{
{{- range $i, $info := .infos}}
	{{if $info.HTTPSkip}}// {{end}}
	{{- $info.HTTP}}: func(err error) error { return {{$info.Semerr}}{err} },
{{- end}}
}

{{- range $i, $info := .infos}}

// {{$info.Semerr}} is the semantic error for {{$info.Name}}.
type {{$info.Semerr}} struct{ Err error }

// Error returns Err.Error() or {{$info.Desc | printf "%q" }}.
func (e {{$info.Semerr}}) Error() string {
	if e.Err == nil {
		return {{$info.Desc | printf "%q" }}
	}
	return e.Err.Error()
}

// Unwrap returns Err.
func (e {{$info.Semerr}}) Unwrap() error { return e.Err }

// GRPCCode returns {{$info.Name}}.
func ({{$info.Semerr}}) GRPCCode() Code { return {{$info.Num}} }

// HTTPStatus returns {{$info.HTTP}}.
func ({{$info.Semerr}}) HTTPStatus() int { return {{$info.HTTP}} }

{{- end}}
`))

func main() {
	flag.Parse()

	if err := run(); err != nil {
		panic(err)
	}
}

func run() error {
	var out io.Writer
	if *outFile == "-" {
		out = os.Stdout
	} else {
		var err error
		out, err = os.OpenFile(*outFile, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)
		if err != nil {
			return err
		}
	}

	infos := make([]codeInfo, len(allCodes))
	for i, c := range allCodes {
		infos[i] = codeInfo{
			Num:      int(c),
			HTTP:     runtime.HTTPStatusFromCode(c),
			HTTPSkip: slices.Contains(httpSkipCodes, c),
			Name:     c.String(),
			Desc:     codeDesc(c),
			Semerr:   fmt.Sprintf("%sError", c),
		}
	}

	if err := generateT.Execute(out, map[string]any{
		"infos": infos,
	}); err != nil {
		return fmt.Errorf("running template %q: %w", generateT.Name(), err)
	}

	return nil
}

// codeDesc returns the semerr description for c.
// It is a hard API contract.
func codeDesc(c codes.Code) string {
	switch c {
	case codes.Canceled:
		return "canceled"
	case codes.Unknown:
		return "unknown"
	case codes.InvalidArgument:
		return "invalid argument"
	case codes.DeadlineExceeded:
		return "deadline exceeded"
	case codes.NotFound:
		return "not found"
	case codes.AlreadyExists:
		return "already exists"
	case codes.PermissionDenied:
		return "permission denied"
	case codes.ResourceExhausted:
		return "resource exhausted"
	case codes.FailedPrecondition:
		return "failed precondition"
	case codes.Aborted:
		return "aborted"
	case codes.OutOfRange:
		return "out of range"
	case codes.Unimplemented:
		return "unimplemented"
	case codes.Internal:
		return "internal"
	case codes.Unavailable:
		return "unavailable"
	case codes.DataLoss:
		return "data loss"
	case codes.Unauthenticated:
		return "unauthenticated"
	default:
		panic(fmt.Sprintf("code %s not mapped", c))
	}
}

var allCodes = []codes.Code{
	// codes.OK is not an error.
	codes.Canceled,
	codes.Unknown,
	codes.InvalidArgument,
	codes.DeadlineExceeded,
	codes.NotFound,
	codes.AlreadyExists,
	codes.PermissionDenied,
	codes.ResourceExhausted,
	codes.FailedPrecondition,
	codes.Aborted,
	codes.OutOfRange,
	codes.Unimplemented,
	codes.Internal,
	codes.Unavailable,
	codes.DataLoss,
	codes.Unauthenticated,
}

var httpSkipCodes = []codes.Code{
	// Clashes with 400/InvalidArgument:
	codes.FailedPrecondition,
	codes.OutOfRange,

	// Clashes with 409/AlreadyExists:
	codes.Aborted,

	// Clashes with 500/Internal:
	codes.DataLoss,
	codes.Unknown,
}
